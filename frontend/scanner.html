<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>QR Pro ‚Äî Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="theme.css" />
  <script type="module" src="theme.js" defer></script>
  <!-- Fallback lib only used if BarcodeDetector is unavailable -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" defer></script>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000000"/>
  <link rel="icon" type="png" href="favicon-32x32.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
  <style>
    /* Camera stage */
    .cam-stage {
      position: relative;
      width: 100%;
      aspect-ratio: 3/4;       /* responsive; fills card area */
      border-radius: 16px;
      overflow: hidden;
      background: #000;
    }
    .cam-stage video,
    .cam-stage canvas {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }

    /* HUD (hidden by default; shown only in debug mode) */
    .hud {
      position: absolute; inset: 10px;
      display: none;                       /* hidden by default */
      align-items: center; justify-content: space-between;
      pointer-events: none;
    }
    body.debug-hud .hud { display: flex; } /* enable via debug mode */

    .chips { display:flex; gap:8px; flex-wrap:wrap }
    .chip {
      pointer-events:auto;
      background: rgba(0,0,0,.45);
      color:#fff; padding:6px 10px; border-radius:999px;
      font-size:.8rem; backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,.25);
    }
    .chip button { all:unset; cursor:pointer; padding:0 2px; }
    .tag { position:absolute; left:10px; bottom:10px; background:rgba(0,0,0,.5); color:#fff; padding:4px 8px; border-radius:8px; font-size:.8rem }

    .bbox { position:absolute; inset:0; pointer-events:none; }

    .result-item {
      display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
      padding:10px 12px; border:1px solid var(--border); border-radius:12px; background:var(--bg);
    }
    .result-item time { color: var(--muted); font-size:.8rem; }
    .result-actions { display:flex; gap:8px; flex-wrap:wrap }
    .list { display:grid; gap:10px; max-height:520px; overflow:auto }
    .footer-note { color: var(--muted); font-size:.9rem }

    /* minor UX niceties to keep responsiveness identical to your original theme */
    @media (max-width: 880px){
      .grid-2 { grid-template-columns: 1fr; }
      .cam-stage { aspect-ratio: 4/5; }
      .container.section { padding-left: 14px; padding-right: 14px; }
    }

  </style>
</head>
<body>
  <!-- Futuristic Loader -->
  <div id="page-loader">
    <div class="loader-container">
      <div class="logo-spin">
        <img src="favicon-32x32.png" alt="Logo" />
      </div>
      <div class="dots">
        <span></span><span></span><span></span>
      </div>
      <div class="status-text">
        <span id="loader-text">Loading...</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill"></div>
      </div>
    </div>
  </div>

  <!-- HEADER -->
  <header class="header">
    <div class="container nav">
      <div class="brand"><div class="brand-logo"></div><div>QR Pro</div></div>
      <nav class="nav-links desktop-only">
        <a data-softnav href="index.html"  class="btn sm">Generator</a>
        <a data-softnav href="studio.html" class="btn sm">Studio</a>
        <a data-softnav href="cube.html"   class="btn sm">3D</a>
        <a data-softnav href="scanner.html" class="btn sm active">Scanner</a>
      </nav>
      <div class="nav-spacer"></div>
      <button class="btn icon" data-theme-toggle title="Toggle theme">üåì</button>
      <button class="hamburger" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </header>

  <!-- DRAWER -->
  <div class="mobile-drawer">
    <div class="drawer-head">
      <div class="brand"><div class="brand-logo"></div><div>QR Pro</div></div>
      <button class="close-btn" aria-label="Close">&times;</button>
    </div>
    <a data-softnav href="index.html"  class="btn sm">Generator</a>
    <a data-softnav href="studio.html" class="btn sm">Studio</a>
    <a data-softnav href="cube.html"   class="btn sm">3D</a>
    <a data-softnav href="scanner.html" class="btn sm active">Scanner</a>
  </div>
  <div class="drawer-backdrop"></div>

  <!-- MAIN -->
  <main class="container section">
    <div class="card" style="position:relative;overflow:hidden">
      <span class="badge">Scanner</span>
      <h1 class="h1">Scan live or decode an image</h1>
      <p class="p-muted">Multi-QR detection, bounding boxes, torch, history, and smart actions. (HUD hidden for users; press <strong>Shift+D</strong> to toggle.)</p>
      <div class="glow"></div>
    </div>

    <div class="grid grid-2" style="margin-top:18px">
      <!-- CAMERA COLUMN -->
      <section class="card">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button id="startCam" class="btn primary">üé• Start camera</button>
          <button id="stopCam" class="btn ghost" disabled>‚èπ Stop</button>
          <button id="torchBtn" class="btn ghost" disabled>üî¶ Torch</button>
          <label class="btn ghost">
            <input id="file" type="file" accept="image/*" style="display:none">
            üì∑ Upload image
          </label>
          <select id="cameraSelect" class="input" style="max-width:260px"></select>
        </div>

        <div class="cam-stage preview" style="margin-top:12px">
          <video id="video" playsinline muted></video>
          <canvas id="overlay" class="bbox"></canvas>

          <!-- HUD: hidden by default; body.debug-hud will show it -->
          <div class="hud" aria-hidden="true">
            <div class="chips">
              <span class="chip" id="fpsChip">FPS: 0</span>
              <span class="chip" id="resChip">0√ó0</span>
            </div>
            <div class="chips">
              <span class="chip">Multi-QR</span>
              <span class="chip" id="engineChip">Engine: ‚Äî</span>
            </div>
          </div>

          <div class="tag">Camera</div>
        </div>
      </section>
      <!-- RESULTS COLUMN -->
      <section class="card">
        <label>Live Results</label>
        <div id="results" class="list" style="margin-top:8px"></div>

        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px">
          <button id="copyAll" class="btn ghost">üìã Copy all</button>
          <button id="clearLive" class="btn ghost">üßπ Clear</button>
        </div>

        <hr style="margin:18px 0; border:none; border-top:1px solid var(--border)">

        <div style="display:flex;align-items:center;gap:10px">
          <h3 style="margin:0">History</h3>
          <button id="clearHistory" class="btn sm ghost" title="Clear history">üßΩ Clear history</button>
        </div>
        <div id="history" class="list" style="margin-top:10px"></div>

        <p class="footer-note" style="margin-top:10px">
          Tip: We detect multiple codes per frame using the browser‚Äôs <code>BarcodeDetector</code> when available, and gracefully fall back to jsQR.
        </p>
      </section>
    </div>
  </main>

  <footer class="footer">Made with ‚ù§Ô∏è by <strong>Prateek</strong></footer>

  <!-- PAGE LOGIC -->
  <script>
    // ---------- Debug HUD control ----------
    (function initDebugHUD(){
      const urlDebug = new URLSearchParams(location.search).get('debug') === '1';
      const saved = localStorage.getItem('QRPRO_debugHUD') === '1';
      if (urlDebug || saved) document.body.classList.add('debug-hud');

      window.addEventListener('keydown', (e)=>{
        if (e.key.toLowerCase() === 'd' && e.shiftKey){
          document.body.classList.toggle('debug-hud');
          localStorage.setItem('QRPRO_debugHUD', document.body.classList.contains('debug-hud') ? '1' : '0');
        }
      });
    })();

    // ---------- Utilities ----------
    const $ = s => document.querySelector(s);
    const resultsEl = $('#results');
    const historyEl = $('#history');
    const overlay = $('#overlay');
    const video = $('#video');
    const torchBtn = $('#torchBtn');
    const startBtn = $('#startCam');
    const stopBtn = $('#stopCam');
    const camSelect = $('#cameraSelect');
    const fpsChip = $('#fpsChip');
    const resChip = $('#resChip');
    const engineChip = $('#engineChip');

    // state
    let stream = null;
    let raf = null;
    let lastFrameTime = performance.now();
    let torchOn = false;
    // prefer native if supported; we'll fallback if it fails
    let usingBarcodeDetector = 'BarcodeDetector' in window;
    let barcodeDetector = null;
    let currentTrack = null;

    // HISTORY: cap at 20 entries
    const HISTORY_KEY = 'QRPRO_scan_history_v2';
    const saveHistory = (items) => localStorage.setItem(HISTORY_KEY, JSON.stringify(items));
    const loadHistory = () => {
      try { return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); }
      catch { return []; }
    };
    const addToHistory = (text) => {
      const items = loadHistory();
      const now = new Date().toISOString();
      if (!items.length || items[0].text !== text) items.unshift({ text, time: now });
      saveHistory(items.slice(0, 20));
      renderHistory();
    };

    // ---------- Smart actions ----------
    function smartButtons(value){
      const actions = [];
      const isURL = /^(https?:\/\/|www\.)/i.test(value);
      const isMail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) || value.startsWith('mailto:');
      const isTel  = /^\+?[0-9\s\-()]{6,}$/.test(value) || value.startsWith('tel:');

      if (isURL) actions.push({label:'Open', href: value.startsWith('http') ? value : 'https://' + value});
      if (isMail) actions.push({label:'Email', href: value.startsWith('mailto:') ? value : ('mailto:' + value)});
      if (isTel)  actions.push({label:'Call',  href: value.startsWith('tel:')    ? value : ('tel:' + value)});

      actions.push({label:'Copy', onClick: async () => {
        await navigator.clipboard.writeText(value);
      }});
      return actions;
    }

    function renderResultItem(text){
      const wrap = document.createElement('div');
      wrap.className = 'result-item';

      const left = document.createElement('div');
      left.innerHTML = `<div style="word-break:break-word">${escapeHtml(text)}</div><time>${new Date().toLocaleString()}</time>`;

      const right = document.createElement('div');
      right.className = 'result-actions';
      smartButtons(text).forEach(a=>{
        if(a.href){
          const link = document.createElement('a');
          link.className = 'btn sm ghost';
          link.textContent = a.label;
          link.href = a.href;
          link.target = '_blank';
          link.rel = 'noopener';
          right.appendChild(link);
        }else{
          const btn = document.createElement('button');
          btn.className = 'btn sm ghost';
          btn.textContent = a.label;
          btn.onclick = a.onClick;
          right.appendChild(btn);
        }
      });

      wrap.appendChild(left);
      wrap.appendChild(right);
      resultsEl.prepend(wrap);
    }

    function renderHistory(){
      const items = loadHistory();
      historyEl.innerHTML = '';
      if (!items.length){
        const p = document.createElement('p');
        p.className = 'p-muted';
        p.textContent = 'No history yet. Start scanning!';
        historyEl.appendChild(p);
        return;
      }
      items.forEach(({text, time})=>{
        const row = document.createElement('div');
        row.className = 'result-item';
        const left = document.createElement('div');
        left.innerHTML = `<div style="word-break:break-word">${escapeHtml(text)}</div><time>${new Date(time).toLocaleString()}</time>`;
        const right = document.createElement('div');
        right.className = 'result-actions';
        (smartButtons(text)).forEach(a=>{
          if(a.href){
            const link = document.createElement('a');
            link.className = 'btn sm ghost';
            link.textContent = a.label;
            link.href = a.href;
            link.target = '_blank';
            link.rel = 'noopener';
            right.appendChild(link);
          }else{
            const btn = document.createElement('button');
            btn.className = 'btn sm ghost';
            btn.textContent = a.label;
            btn.onclick = a.onClick;
            right.appendChild(btn);
          }
        });
        row.appendChild(left);
        row.appendChild(right);
        historyEl.appendChild(row);
      });
    }

    function escapeHtml(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
    // ---------- Camera management (improved auto-start with back-first & front-fallback) ----------
    async function listCameras(){
      camSelect.innerHTML = '';
      try {
        const devices = (await navigator.mediaDevices.enumerateDevices())
          .filter(d => d.kind === 'videoinput');
        devices.forEach((d, i)=>{
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${i+1}`;
          camSelect.appendChild(opt);
        });
      } catch (e) {
        console.warn('enumerateDevices error', e);
      }
    }

    // Start with a preferred constraint object:
    // - try facingMode: { ideal: 'environment' } first
    // - if that fails, try facingMode: { ideal: 'user' }
    // - if that fails, try the first enumerated deviceId
    async function autoStartCamera(){
      // populate camera list first (labels may be empty until user approves permission)
      await listCameras();

      // If user previously selected a device, try that first
      const saved = localStorage.getItem('QRPRO_last_camera_id');
      if(saved){
        try {
          await startCamera({ deviceId: { exact: saved } });
          return;
        } catch (e) {
          console.warn('Saved device failed, will try facingMode fallback', e);
        }
      }

      // Try back camera first
      try {
        await startCamera({ facingMode: { ideal: 'environment' } });
        return;
      } catch (e) {
        console.warn('environment facingMode failed, trying user facing', e);
      }

      // Fallback to front camera
      try {
        await startCamera({ facingMode: { ideal: 'user' } });
        return;
      } catch (e) {
        console.warn('user facing failed, trying enumerated deviceId', e);
      }

      // Last resort: try first enumerated device
      const firstOpt = camSelect.querySelector('option');
      if (firstOpt) {
        try {
          await startCamera({ deviceId: firstOpt.value });
          return;
        } catch (e) {
          console.error('All attempts to start camera failed', e);
          alert('Unable to start camera: ' + (e && e.message ? e.message : 'Unknown'));
        }
      } else {
        alert('No camera devices found.');
      }
    }

    // start camera with provided constraints object
    async function startCamera(preferredConstraints = {}){
      // stop existing
      stopCamera();
      await listCameras();

      const constraints = {
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          ...preferredConstraints
        },
        audio: false
      };

      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
      }catch(e){
        // bubble up so autoStartCamera can fall back
        throw e;
      }

      video.srcObject = stream;
      try { await video.play(); } catch(e){ console.warn('video.play failed', e); }
      currentTrack = stream.getVideoTracks()[0];

      // Save device id to preferences (if available)
      try {
        const deviceId = currentTrack.getSettings?.().deviceId;
        if (deviceId) {
          localStorage.setItem('QRPRO_last_camera_id', deviceId);
          // set select if matches
          const opt = Array.from(camSelect.options).find(o => o.value === deviceId);
          if (opt) camSelect.value = deviceId;
        }
      } catch (e) {}

      // Torch availability
      const caps = currentTrack.getCapabilities?.() || {};
      const canTorch = !!caps.torch;
      torchBtn.disabled = !canTorch;
      torchOn = false;

      // Resolution chip (may be 0 until metadata loaded)
      setTimeout(()=> {
        resChip.textContent = `${video.videoWidth}√ó${video.videoHeight}`;
      }, 300);

      // Prepare overlay canvas to match element size
      overlay.width = overlay.clientWidth;
      overlay.height = overlay.clientHeight;

      // Keep overlay in sync with element resize (orientation, layout)
      new ResizeObserver(()=>{
        overlay.width = overlay.clientWidth;
        overlay.height = overlay.clientHeight;
      }).observe(overlay.parentElement);

      // Pick engine (try BarcodeDetector; fallback to jsQR if any error)
      if(usingBarcodeDetector){
        try{
          // attempt to create a detector and run a quick test detect on a 1x1 canvas to ensure support
          barcodeDetector = new BarcodeDetector({ formats: ['qr_code'] });
          engineChip.textContent = 'Engine: BarcodeDetector';
        }catch(err){
          console.warn('BarcodeDetector unavailable, falling back to jsQR', err);
          usingBarcodeDetector = false;
          engineChip.textContent = 'Engine: jsQR (fallback)';
          barcodeDetector = null;
        }
      } else {
        engineChip.textContent = 'Engine: jsQR (fallback)';
      }

      startBtn.disabled = true;
      stopBtn.disabled = false;

      // begin detection loop
      tick();
    }

    function stopCamera(){
      if (raf) cancelAnimationFrame(raf), raf = null;
      if (stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      torchBtn.disabled = true;
      torchOn = false;
      const ctx = overlay.getContext('2d');
      ctx && ctx.clearRect(0,0,overlay.width,overlay.height);
    }

    async function toggleTorch(){
      if (!currentTrack) return;
      const caps = currentTrack.getCapabilities?.() || {};
      if(!caps.torch) {
        alert('Torch not supported on this device.');
        return;
      }
      torchOn = !torchOn;
      try {
        await currentTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
        torchBtn.textContent = torchOn ? 'üî¶ Torch On' : 'üî¶ Torch';
      } catch (e) {
        console.warn('applyConstraints torch failed', e);
        alert('Unable to toggle torch: ' + (e.message || e));
        torchOn = false;
      }
    }

    // ---------- Detection loop ----------
    const seenThisFrame = new Set();

    function drawBoxes(boxes){
      const ctx = overlay.getContext('2d');
      const vw = video.videoWidth || 1, vh = video.videoHeight || 1;
      const cw = overlay.width || overlay.clientWidth, ch = overlay.height || overlay.clientHeight;

      ctx.clearRect(0,0,cw,ch);
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(16,185,129,0.95)'; // green
      ctx.fillStyle = 'rgba(16,185,129,0.12)';

      boxes.forEach(b=>{
        // Map video coords -> canvas coords (letter/pillarboxing safe)
        const videoRatio = vw / vh;
        const canvasRatio = cw / ch;
        let sx=0, sy=0, sw=cw, sh=ch;
        if (canvasRatio > videoRatio){
          const drawW = ch * videoRatio;
          sx = (cw - drawW)/2;
          sw = drawW;
        } else {
          const drawH = cw / videoRatio;
          sy = (ch - drawH)/2;
          sh = drawH;
        }
        const scaleX = sw / vw;
        const scaleY = sh / vh;

        const pts = b.corners.map(p => ({
          x: sx + p.x * scaleX,
          y: sy + p.y * scaleY
        }));

        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();

        // label
        ctx.font = '12px ui-sans-serif, system-ui, Segoe UI, Roboto, Arial';
        ctx.fillStyle = 'rgba(0,0,0,.75)';
        const label = 'QR';
        const w = ctx.measureText(label).width + 10;
        const px = Math.min(Math.max(pts[0].x, 0), cw - w);
        const py = Math.min(Math.max(pts[0].y - 18, 0), ch - 18);
        ctx.fillRect(px, py, w, 16);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, px+5, py+12);
      });
    }

    async function tick(){
      // FPS
      const now = performance.now();
      const dt = now - lastFrameTime;
      lastFrameTime = now;
      const fps = Math.round(1000 / Math.max(1, dt));
      fpsChip.textContent = 'FPS: ' + fps;

      // Refresh res (orientation changes etc.)
      resChip.textContent = `${video.videoWidth}√ó${video.videoHeight}`;

      const boxes = [];
      const foundTexts = [];

      if (usingBarcodeDetector && barcodeDetector){
        try{
          const barcodes = await barcodeDetector.detect(video); // multiple
          for (const b of barcodes){
            const raw = b.rawValue;
            if (raw && !seenThisFrame.has(raw)){
              foundTexts.push(raw);
            }
            if (b.cornerPoints && b.cornerPoints.length){
              boxes.push({ corners: b.cornerPoints.map(p=>({x:p.x, y:p.y})) });
            } else if (b.boundingBox){
              const r = b.boundingBox;
              boxes.push({ corners:[
                {x:r.x, y:r.y},
                {x:r.x+r.width, y:r.y},
                {x:r.x+r.width, y:r.y+r.height},
                {x:r.x, y:r.y+r.height}
              ]});
            }
          }
        }catch(err){
          // If BarcodeDetector errors at runtime, gracefully fallback to jsQR
          console.warn('BarcodeDetector runtime error; switching to jsQR fallback', err);
          usingBarcodeDetector = false;
          engineChip.textContent = 'Engine: jsQR (fallback)';
          barcodeDetector = null;
        }
      }

      if (!usingBarcodeDetector){
        // Fallback with region sampling (pseudo multi-QR)
        const c = document.createElement('canvas');
        const w = video.videoWidth, h = video.videoHeight;
        if (w && h){
          c.width = w; c.height = h; const ctx = c.getContext('2d');
          try {
            ctx.drawImage(video,0,0,w,h);
            const tryRegions = [
              {x:0,y:0,w,h},
              {x:0,y:0,w:Math.floor(w/2),h:Math.floor(h/2)},
              {x:Math.floor(w/2),y:0,w:Math.floor(w/2),h:Math.floor(h/2)},
              {x:0,y:Math.floor(h/2),w:Math.floor(w/2),h:Math.floor(h/2)},
              {x:Math.floor(w/2),y:Math.floor(h/2),w:Math.floor(w/2),h:Math.floor(h/2)},
            ];
            const added = new Set();
            for (const r of tryRegions){
              let data;
              try {
                data = ctx.getImageData(r.x,r.y,r.w,r.h);
              } catch(e) { continue; } // some browsers may throw if region invalid
              const code = jsQR(data.data, data.width, data.height, { inversionAttempts: 'attemptBoth' });
              if (code && code.data && !added.has(code.data)){
                added.add(code.data);
                foundTexts.push(code.data);
                const cns = code.location;
                boxes.push({ corners: [
                  {x:cns.topLeftCorner.x   + r.x, y:cns.topLeftCorner.y   + r.y},
                  {x:cns.topRightCorner.x  + r.x, y:cns.topRightCorner.y  + r.y},
                  {x:cns.bottomRightCorner.x+r.x, y:cns.bottomRightCorner.y+r.y},
                  {x:cns.bottomLeftCorner.x +r.x, y:cns.bottomLeftCorner.y +r.y},
                ]});
              }
            }
          } catch (e) {
            // ignore canvas draw issues
          }
        }
      }

      // Draw boxes
      drawBoxes(boxes);

      // Render newly found texts
      seenThisFrame.clear();
      for (const t of foundTexts){
        seenThisFrame.add(t);
        renderResultItem(t);
        addToHistory(t);
      }

      raf = requestAnimationFrame(tick);
    }
    // ---------- File upload decode ----------
    $('#file').addEventListener('change', async e=>{
      const file = e.target.files[0]; if(!file) return;
      const img = new Image();
      img.src = URL.createObjectURL(file);
      try { await img.decode(); } catch(err) { /* ignore decode issues */ }

      const c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width; c.height = img.naturalHeight || img.height;
      const ctx = c.getContext('2d');
      ctx.drawImage(img,0,0,c.width,c.height);

      let hits = [];

      if (usingBarcodeDetector){
        try{
          const bmp = await createImageBitmap(c);
          const det = new BarcodeDetector({ formats:['qr_code'] });
          const codes = await det.detect(bmp);
          hits = codes.map(b=>b.rawValue).filter(Boolean);
        }catch(err){
          // fallback to jsQR
          console.warn('BarcodeDetector on image failed, falling back to jsQR', err);
        }
      }
      if (!hits.length){
        try {
          const data = ctx.getImageData(0,0,c.width,c.height);
          const code = jsQR(data.data, data.width, data.height, { inversionAttempts:'attemptBoth' });
          if (code && code.data) hits = [code.data];
        } catch (e) {
          console.warn('jsQR decode failed', e);
        }
      }

      if (hits.length){
        hits.forEach(t=>{ renderResultItem(t); addToHistory(t); });
      }else{
        alert('No QR found in the image.');
      }
      URL.revokeObjectURL(img.src);
    });

    // ---------- Buttons & init ----------
    startBtn.addEventListener('click', async ()=>{
      try {
        await startCamera({ facingMode: { ideal: 'environment' } });
      } catch (e) {
        console.warn('start button start failed', e);
      }
    });
    stopBtn.addEventListener('click', stopCamera);
    torchBtn.addEventListener('click', toggleTorch);
    camSelect.addEventListener('change', async ()=>{
      const id = camSelect.value;
      if (!id) return;
      try {
        await startCamera({ deviceId: { exact: id } });
      } catch (e) {
        console.warn('start with deviceId failed', e);
        alert('Cannot start selected camera: ' + (e.message || e));
      }
    });

    $('#copyAll').addEventListener('click', async ()=>{
      const texts = [...resultsEl.querySelectorAll('.result-item > div:first-child > div:first-child')]
        .map(n=>n.textContent.trim());
      if(!texts.length) return;
      await navigator.clipboard.writeText(texts.join('\n'));
    });

    $('#clearLive').addEventListener('click', ()=>{
      resultsEl.innerHTML = '';
      const ctx = overlay.getContext('2d');
      ctx && ctx.clearRect(0,0,overlay.width,overlay.height);
    });

    $('#clearHistory').addEventListener('click', ()=>{
      saveHistory([]);
      renderHistory();
    });

    // Warm-up and auto-start
    (async ()=>{
      renderHistory();
      await listCameras();
      // Try to auto-start: back camera first, then front, then enumerated device
      try {
        await autoStartCamera();
      } catch (e) {
        console.warn('autoStartCamera failed', e);
      }
    })();

    // Clean up on leave
    window.addEventListener('beforeunload', stopCamera);

    // Expose a helpful debug function in console (optional)
    window.QRPRO = {
      startCamera, stopCamera, listCameras, currentTrack: () => currentTrack
    };
  </script>
</body>
</html>
